"""
{system_name} Coordinator Agent.

This agent coordinates {num_agents} specialized agents using hierarchical delegation.
Generated by AgentBuilder on {timestamp}.
"""

import os
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class DelegationDecision:
    """Represents a decision to delegate a task to a specialized agent."""
    target_agent: str
    task_description: str
    parameters: Dict[str, Any]
    requires_human_approval: bool = False
    approval_reason: Optional[str] = None


@dataclass
class AgentResult:
    """Result from a specialized agent execution."""
    agent_name: str
    task: str
    success: bool
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class {coordinator_class_name}:
    """
    {system_name} Coordinator Agent.

    Orchestrates {num_agents} specialized agents:
{agent_list}
    """

    def __init__(self, project_id: Optional[str] = None):
        """Initialize coordinator."""
        self.project_id = project_id or os.getenv("GOOGLE_CLOUD_PROJECT")
        self.specialized_agents: Dict[str, Any] = {{}}
        self.delegation_history: List[DelegationDecision] = []
        self.results_history: List[AgentResult] = []

        logger.info(f"{{self.__class__.__name__}} initialized")

    def register_specialized_agent(self, name: str, agent: Any) -> None:
        """Register a specialized agent for delegation."""
        self.specialized_agents[name] = agent
        logger.info(f"Registered specialized agent: {{name}}")

    def determine_delegation(self, user_request: str) -> List[DelegationDecision]:
        """
        Analyze user request and determine which agents to delegate to.

        {routing_strategy_comment}
        """
        decisions = []
        request_lower = user_request.lower()

        # Keyword mappings for each agent
        keyword_map = {{
{keyword_mappings}
        }}

        for agent_name, keywords in keyword_map.items():
            if any(kw in request_lower for kw in keywords):
                decisions.append(DelegationDecision(
                    target_agent=agent_name,
                    task_description=f"Process: {{user_request}}",
                    parameters={{'query': user_request}}
                ))

        # Fallback if no keywords matched
        if not decisions:
            decisions.append(DelegationDecision(
                target_agent='{default_agent}',
                task_description=f"General query: {{user_request}}",
                parameters={{'query': user_request}}
            ))

        self.delegation_history.extend(decisions)
        return decisions

    def execute_delegation(self, decision: DelegationDecision) -> AgentResult:
        """Execute a delegation decision by routing to specialized agent."""
        if decision.requires_human_approval:
            logger.warning(f"Human approval required: {{decision.approval_reason}}")
            return AgentResult(
                agent_name=decision.target_agent,
                task=decision.task_description,
                success=False,
                error=f"Human approval required: {{decision.approval_reason}}"
            )

        agent = self.specialized_agents.get(decision.target_agent)

        if not agent:
            logger.error(f"Agent not found: {{decision.target_agent}}")
            return AgentResult(
                agent_name=decision.target_agent,
                task=decision.task_description,
                success=False,
                error=f"Agent '{{decision.target_agent}}' not registered"
            )

        try:
            result = agent.execute(**decision.parameters)

            agent_result = AgentResult(
                agent_name=decision.target_agent,
                task=decision.task_description,
                success=True,
                result=result
            )

            self.results_history.append(agent_result)
            return agent_result

        except Exception as e:
            logger.error(f"Error executing {{decision.target_agent}}: {{e}}")
            return AgentResult(
                agent_name=decision.target_agent,
                task=decision.task_description,
                success=False,
                error=str(e)
            )

    def aggregate_results(self, results: List[AgentResult]) -> Dict[str, Any]:
        """Aggregate results from multiple specialized agents."""
        aggregated = {{
            'summary': '',
            'insights': {{}},
            'recommendations': [],
            'next_steps': [],
            'success': all(r.success for r in results),
            'errors': [r.error for r in results if not r.success]
        }}

        for result in results:
            if result.success and result.result:
                aggregated['insights'][result.agent_name] = result.result

        if aggregated['insights']:
            aggregated['summary'] = f"Successfully gathered insights from {{len(aggregated['insights'])}} agents"

        return aggregated

    def process_request(self, user_request: str) -> Dict[str, Any]:
        """Main entry point for processing requests."""
        logger.info(f"Processing request: {{user_request[:100]}}...")

        decisions = self.determine_delegation(user_request)
        logger.info(f"Determined {{len(decisions)}} delegation(s)")

        results = []
        for decision in decisions:
            logger.info(f"Delegating to {{decision.target_agent}}")
            result = self.execute_delegation(decision)
            results.append(result)

        aggregated = self.aggregate_results(results)

        return {{
            'request': user_request,
            'delegations': [
                {{
                    'agent': d.target_agent,
                    'task': d.task_description,
                    'requires_approval': d.requires_human_approval
                }}
                for d in decisions
            ],
            'results': aggregated,
            'metadata': {{
                'total_delegations': len(decisions),
                'successful_delegations': sum(1 for r in results if r.success),
                'failed_delegations': sum(1 for r in results if not r.success),
            }}
        }}

    def get_delegation_stats(self) -> Dict[str, Any]:
        """Get statistics about delegation history."""
        if not self.delegation_history:
            return {{'total_delegations': 0}}

        agent_counts = {{}}
        for decision in self.delegation_history:
            agent_counts[decision.target_agent] = agent_counts.get(decision.target_agent, 0) + 1

        success_rate = (
            sum(1 for r in self.results_history if r.success) / len(self.results_history)
            if self.results_history else 0
        )

        return {{
            'total_delegations': len(self.delegation_history),
            'delegations_by_agent': agent_counts,
            'total_results': len(self.results_history),
            'success_rate': success_rate,
        }}


def main():
    """Test the coordinator agent."""
    import json
    coordinator = {coordinator_class_name}()

    # Example requests
    example_requests = [
{example_requests}
    ]

    for request in example_requests:
        print(f"\n{{'='*80}}")
        print(f"Request: {{request}}")
        print(f"{{'='*80}}")

        response = coordinator.process_request(request)
        print(json.dumps(response, indent=2))

    # Show delegation statistics
    print(f"\n{{'='*80}}")
    print("Delegation Statistics")
    print(f"{{'='*80}}")
    print(json.dumps(coordinator.get_delegation_stats(), indent=2))


if __name__ == "__main__":
    main()
